// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getHourses = `-- name: GetHourses :many
WITH duplicate_conditions AS (
    SELECT MIN(id) AS id, section_id, address, age, area
    FROM hourse
    WHERE link LIKE 'https://sale.591.com.tw/home%'
    AND updated_at > CURRENT_TIMESTAMP - INTERVAL '7 day'
    GROUP BY section_id, address, age, area
    HAVING count(1) > 1
),
duplicate AS (
    SELECT hourse.id
    FROM hourse
    INNER JOIN duplicate_conditions ON(
            hourse.section_id = duplicate_conditions.section_id
        AND hourse.address = duplicate_conditions.address
        AND hourse.age = duplicate_conditions.age
        AND hourse.area = duplicate_conditions.area
        AND hourse.link LIKE 'https://sale.591.com.tw/home%'
    )
    WHERE hourse.id NOT IN (SELECT id FROM duplicate_conditions)
    AND hourse.updated_at > CURRENT_TIMESTAMP - INTERVAL '7 day'
),
candidates AS (
SELECT hourse.id
FROM hourse
LEFT JOIN section ON(hourse.section_id = section.id)
LEFT JOIN city ON(hourse.city_id = city.id)
WHERE hourse.updated_at > CURRENT_TIMESTAMP - INTERVAL '7 day'
    AND hourse.id NOT IN (SELECT id FROM duplicate)
    AND (city.name = ANY($1 :: VARCHAR[]) OR COALESCE($1, '') = '')
    AND (hourse.shape IN ($2 :: VARCHAR[]) OR COALESCE($2, '') = '')
    AND (section.name IN ($3 :: VARCHAR[]) OR COALESCE($3, '') = '')
    AND (hourse.price <= $4 :: DECIMAL OR COALESCE($4, '') = '')
    AND (hourse.price > $5 :: DECIMAL OR COALESCE($5, '') = '')
    AND (hourse.age < $6 OR COALESCE($6, '') = '')
    AND (hourse.main_area <= $7 :: DECIMAL OR COALESCE($7, '') = '')
    AND (hourse.main_area > $8 :: DECIMAL OR COALESCE($8, '') = '')
)
SELECT
    hourse.id, hourse.universal_id, hourse.section_id, hourse.link, hourse.layout, hourse.address, hourse.price, hourse.floor, hourse.shape, hourse.age, hourse.area, hourse.main_area, hourse.raw, hourse.others, hourse.created_at, hourse.updated_at, hourse.deleted_at,
    CONCAT(city.name, section.name, hourse.address) :: VARCHAR AS location,
    city.name :: TEXT AS city,
    section.name :: TEXT AS section,
    (SELECT COUNT(1) FROM candidates) AS total_count
FROM hourse
INNER JOIN candidates USING(id)
LEFT JOIN section ON (section.id=hourse.section_id)
LEFT JOIN city ON (city.id=section.city_id)
ORDER BY hourse.age, hourse.price, hourse.main_area
`

type GetHoursesParams struct {
	City        []string
	Shape       []string
	Section     []string
	MaxPrice    string
	MinPrice    string
	Age         string
	MaxMainArea string
	MinMainArea string
}

type GetHoursesRow struct {
	ID          int64
	UniversalID uuid.UUID
	SectionID   int32
	Link        string
	Layout      sql.NullString
	Address     sql.NullString
	Price       string
	Floor       string
	Shape       string
	Age         string
	Area        string
	MainArea    sql.NullString
	Raw         json.RawMessage
	Others      []string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
	Location    string
	City        string
	Section     string
	TotalCount  int64
}

func (q *Queries) GetHourses(ctx context.Context, arg GetHoursesParams) ([]GetHoursesRow, error) {
	rows, err := q.db.QueryContext(ctx, getHourses,
		pq.Array(arg.City),
		pq.Array(arg.Shape),
		pq.Array(arg.Section),
		arg.MaxPrice,
		arg.MinPrice,
		arg.Age,
		arg.MaxMainArea,
		arg.MinMainArea,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHoursesRow
	for rows.Next() {
		var i GetHoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.UniversalID,
			&i.SectionID,
			&i.Link,
			&i.Layout,
			&i.Address,
			&i.Price,
			&i.Floor,
			&i.Shape,
			&i.Age,
			&i.Area,
			&i.MainArea,
			&i.Raw,
			pq.Array(&i.Others),
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Location,
			&i.City,
			&i.Section,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCity = `-- name: InsertCity :one
INSERT INTO city (name) VALUES ($1) ON CONFLICT(name) DO UPDATE SET name = $1 RETURNING id
`

func (q *Queries) InsertCity(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertCity, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertSection = `-- name: InsertSection :one
INSERT INTO section (name, city_id) VALUES ($1, $2) ON CONFLICT(name, city_id) DO UPDATE SET name = $1 RETURNING id
`

type InsertSectionParams struct {
	Name   string
	CityID int32
}

func (q *Queries) InsertSection(ctx context.Context, arg InsertSectionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertSection, arg.Name, arg.CityID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertHourse = `-- name: UpsertHourse :exec
INSERT INTO hourse (section_id, link, layout, address, price, floor, shape, age, area, main_area, raw, others ,created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 ,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT (link) DO UPDATE SET price = $5, raw = $11, age = $8, updated_at = CURRENT_TIMESTAMP
`

type UpsertHourseParams struct {
	SectionID int32
	Link      string
	Layout    sql.NullString
	Address   sql.NullString
	Price     string
	Floor     string
	Shape     string
	Age       string
	Area      string
	MainArea  sql.NullString
	Raw       json.RawMessage
	Others    []string
}

func (q *Queries) UpsertHourse(ctx context.Context, arg UpsertHourseParams) error {
	_, err := q.db.ExecContext(ctx, upsertHourse,
		arg.SectionID,
		arg.Link,
		arg.Layout,
		arg.Address,
		arg.Price,
		arg.Floor,
		arg.Shape,
		arg.Age,
		arg.Area,
		arg.MainArea,
		arg.Raw,
		pq.Array(arg.Others),
	)
	return err
}
